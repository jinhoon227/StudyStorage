## 객체지향 Chap6

본 글은 오브젝트(조영호) 를 읽고 정리한 글이다. 객체지향이 무엇인가? 에 대해
자세히 알고싶어서 책을 읽고 기억하기 위해 기록한다. 이번 글에서는 Chapter6 메시지와 인터페이스를
읽고 정리해보았다. 이번 챕터는 클래스가 아닌 객체를 지향하는것을 목표로 한다.

## 클라이언트 - 서버 모델

두 객체 협력 관계를 설명할때 메시지를 전송하는 객체를 클라이언트, 메세지를 수신하는 객체를 서버
라고 부른다. 설계를 할때 **수신하는 메시지의 집합**과 **송신하는 메시지의 집합** 함께 고려해야 한다.

### 용어 정리

- 메시지 : 오퍼레이션명과 인자로 구성되어 있다.
- 메시지 전송 : 메시지 + 메시지 수진자.
- 메서드 : 메시지를 수신했을때 실제로 실행되는 함수(or 프로시저), 수신자의 인스턴스에 따라 다른 함수가 실행될 수 있다.
- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부로 공개하는 메시지의 집합
- 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지, 수행 가능한 행동의 추상화한 것이며 시그니처만 정의한것이다.
- 시그니처 : 오퍼레이션(or 메서드)의 이름과 파라미터 목록을 합친 것이다.

객체지향에서 메시지 전송은 코드 상에서 정확히 무엇이 실행되는지 알 수 없다는 모호함이 있다.
그저 메시지에 응답할 객체가 있을거라 생각하고, 그 객체가 알아서 적절한 메서드를 선택한다고 믿을 뿐이다.
하지만 이 모호함을 가짐으로써 객체의 자율성을 높인다.

## 인터페이스와 설계품질

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스 조건을 갖춰야한다. 그러기 위해 책임 주도 설계 방법을
사용하여 메시지를 선택하는 방식을 사용한다. 
해당 방법을 통해 좋은 인터페이스를 설계할 수 있지만, 좋은 인터페이스의 특징이
무엇인지 정확히 알기위해 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법을 소개한다.

### 디미터 법칙

객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는것이다. 클래스 내부의 메서드가
아래조건을 만족하는 인스턴스에만 메시지를 전송하도록 한다.
- this 객체
- 메서드의 매개변수
- this 의 속성
- this 의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역객체

위와 같은 규칙을 지켜 협력하는 객체에 대하여 내부구조를 묻지 않고 무언가를 시킨다는게 중요하다.

```java
screening.getMovie().getDiscountConditions();
```

위의 코드는 디미터 법칙을 위반하는 코드이다. 메시지 전송자가 수신자의 내부 구조에 대해 묻고, 반환받은
요소에 연쇄적으로 메시지를 전송한다. 이를 기차 충돌이라고도 부르며 이는 내부구현이 외부로 노출됐다는 뜻이다.
.(dot) 사용해 연결되는 경우 내부구현이 들어났을 경우가 높으니 확인해보자.

```java
screening.calculateFee(audienceCount);
```

디미터의 법칙을 따른다면 위와 같이 송신자는 수신자의 구현부를 알 필요없이 원하는것을 수행하도록 요청만 한다.

### 묻지 말고 시켜라

> Tell, Don't Ask

디미터 법칙에서 메세지지는 객체의 상태에 관해 묻지 않고 원하는 것을 시켜야 한다는 사실을 강조했다.
묻지 말고 시켜라는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어이다.

### 의도를 드러내는 인터페이스

켄트벡의 Smalltalk Best Practice Patterns 책에서는 메서드 명명법을 두 가지 제시햇다.
첫번째는 메서드가 작업을 어떻게 수행하는지 나타낸것인데 이는 안좋은 스타일이다.

```java
public class PeriodCondition {
    public boolean isSatisfiedByPeriod(Screening screening) { ... }
}
public class SequenceCondition {
    public boolean isSatisfiedBySequence(Screening screening) { ... }
}
```

위와같이 어떻게 수행하는지 메서드명을 지으면 다음과 같은 단점이 있다.
- 내부구현이 메서드명으로 들어나면서 캡슐화를 위반한다. 이를 코드에 적용하면 클라이언트는 객체의 종류를 알게되고, 변경이 있을때 참조객체를 바꾸는게 아닌 호출하는 메서드를 변경해야한다.(이는 서버와 클라이언트 모두 변경을 해야된다)
- 메스드에 대해 제대로 커뮤니케이션 하지 못한다. 둘 다 할인 조건 판단하는 동일한 작업이지만 이름이 달라 내부구현의 이해가 필요해졌다.

두번째 이름 짓는 방법을 '어떻게'가 아닌 '무엇'을 들어내는 것이다.
위의 예제에서 할인 여부를 판단하는 동일한 목적을 가진다. 그래서 `isSatisfiedBy` 로 명명하여
두 클래스의 목적을 달성할 수 있다. 이렇게 하면 클라이언트 입장에서 두 메서드를 동일한 방식으로 사용할 수 있다.

## 원칙의 함정

설계는 트레이드오프의 산물이다. 그러니 원칙만 지키다보면 더 안좋은 품질의 설계가 될 수 있다.

### 디미터 법칙 dot

> 디미터 법칙은 하나의 dot(.) 를 강제하는 규칙이 아니다

디미터 법칙이 하나의 도트(.)를 사용하도록 했지만 이는 정확한건 아니다.
자바의 Stream 은 체이닝을 통해 여러 도트(.) 를 사용한다.

```java
IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();
```

위의 스트림은 숫자를 10보다 큰 수를 필터링후 중복제거후 개수를 세는 로직이다.
해당 `IntStream` 은 다른 `IntStream` 으로 변환할뿐, 외부로 구현부분이 노출되는게 아니다.
그러니 결합도가 문제가 되지 않으며 이는 디미터 법칙을 위반하지 않는다.

### 결합도와 응집도의 충돌

```java
public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

해당 로직은 `screening` 이 가진 `getDayOfWeek()` `getStartTime()` 를 호출하고 연쇄적으로
함수를 호출하면서 디미터법칙과 묻지말고시켜라 원칙을 위배한다. 따라서 이를 `Screening` 이 판단할 수 있도록 한다.

```java
public class Screening {
    public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {
        return whenScreened.getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(whenScreened.toLocalTime()) <= 0 &&
                endTime.compareTo(whenScreened.toLocalTime()) >= 0;
    }
}

public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) {
        return screening.isDiscountable(dayOfWeek, startTime, endTime);
    }
}
```

하지만 `Screening` 이 판단하도록 코드를 바꾸니 할인 판단 책임이 `Screening` 으로 넘어갔다.
이는 `Screening` 의 캡슐화를 높였지만 결과적으로 `Screening` 의 응집도를 낮추고 `Screening` 과 `PeriodCondition`
사이의 결합도가 올라갔다.

항상 디미터법칙을 적용하는게 좋은게 아니다. 시키는것 말고도 묻는것도 하나의 방법이다. 로버튼 마틴의 클린코드에서는 
객체는 내부 구조르 숨겨야하므로 디미터 법칙을 따르는게 좋지만, 자료 구조라면 당연히 내부를 노출해야 하니 디미터
적용을 법칙을 적용할 필요가 없다고도 했다. 시키지는게 아니라 묻는것도 방법임을 알아두자.

## 명령 - 쿼리 분리원칙

가끔씩 물어야된다는걸 알았다. 언제 물어야될지 알기위해 **명령-쿼리 분리 원칙**이 있다.

- 명령 : 객체의 상태를 수정하는 오퍼레이션, 반환값을 가질 수 없다.
- 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션, 상태를 변경할 수 없다.

명령과 쿼리를 동시에 실행하는 메서드가 있으면 실행결과를 예측하기 매우 어려워진다.
반대로 명령과 쿼리를 분리함으로써 유지보수성을 높일 수 있다.
쿼리는 객체의 상태를 변경하지 않아 몇번을 호출해도 결과값이 같기 때문에 쿼리의 결과를 예측하기 쉽기 때문이다.

즉 부수효과(side-effect) 를 가지는 명령과, 부수효과를 가지지 않는 쿼리로 분리함으로써 참조투명성을 혜택을 
조금 누릴 수 있다.

참조투명성의 장점
- 모든 함수를 이미 알고 잇는 하나의 결괏값을 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
- 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.

## 결론

훌륭한 인터페이스를 만들고싶다면 메시지를 선택하는 방식으로 디미터법칙, 묻지말고 시켜라 원칙, 의도를 드러내는 인터페이스, 명령-쿼리 원칙
이 네가지를 고려하는게 좋다.


## 스터티 결과



## Reference

> 오브젝트 : 코드로 이해하는 객체지향 설계(조영호)