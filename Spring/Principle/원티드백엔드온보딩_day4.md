## Day4 - 스레드 동기화와 동시성

원티드 백엔드 프리 온보딩 코스에서 김재녕님 강의를 들으면서 작성한 글이다.
이번 강의는 스레드 동기화와 동시성에 대해 설명한다.

가상스레드 : 스레드는 프로세스에 비해 컨텍스트 스위칭 비용이 덜 들지만,
그래도 큰 비용이기 때문에 가상스레드 개념이 나타났다.

프로세스와 스레드에서의 장단점

장점
- 리소스 공유 원활
- 멀티스레드는 실제로 병렬처리가 가능
- 프로세스 컨텍스 스위칭보다 빠름

단점
- 스레드 그룹은 리소스 공유로 인해 하나의 스레드가 오작동 일으키면
다른 스레드도 영향을 받음
- 서로 다른 시스템에서 실행될 수 없음

## Java Thread

`java.lang.Thread` 를 통해 생성이 가능
- 모든 스레드는 이름을 가지고있으며 여러 스레드가 같은 이름을 가질 수 있다.
- 모든 스레드는 우선순위가 있지만 항상 지켜지는건 아님. OS 에 연결된
- 스레드에 따라 바뀔 수 있기 때문이다.
- 데몬스레드가 존재하면 설정이 가능하다.
- 종료조건은 Runtime.getRuntime().exit() 메서도 호출 또는 유저스레드 종료시

Daemon Thread
- Java 는 User Thread 와 Daemon Thead 두 가지 지원
- 데몬스레드는 우선순위가 낮으며 JVM 종료를 막지 않음
- I/O 작업에는 사용권장안함
- GC, 메모리해제, 캐시에서 원하지 않는항목 제거할때 사용함

User Thread 가 있으면 프로그램 종료가 안되지만
Daemon Thread 는 존재여부 상관없이 프로그램 종료가 된다.
User Thread 가 종료되면 Daemon Thread 도 강제종료된다.

### 동시성

Concurrency
- 여러 작업이 겹치는 시점에 실행하는것, 그러나 실제로
동시에 실행되지 않음, CPU 작업 당 시간을 조정하면 적절한 컨텍스트 스위칭처리

Parallelism
- 동시에 독릭적인 작업을 실행하는것

### Mutex

Mutual Exclusion : 상호배제란 레이스 컨디션 방지하기
위해서 정의된 동시성 제어, 상호배제를 하기위한것

Semaphore : 멀티 스레드가 공유 리소스에 액세스하는 것을 제어함
동시성 처리에서 크리티컬 섹션문제를 해결하기 위한 변수.

Monitor : 스레드의 동기화 메커니즘, 객체의 인스턴스마다 존재한다.
스레드가 일부 리소스에 엑세스하는것을 모니터링한다.
- mutex : 락을 통해 특정 시점에 단 하나의 스레드만 메서드를 실행가능
- cooperation : wait-set 을 사용해 특정 조건까지 대기하도록 하는 기능

Java Monitor : `synchronized` 키워드를 사용해 크리티컬 섹션 표현
`synchronized` 블락은 성능 측면에서 효율적
Java 에는 모니터가 객체(인스턴스)와 클래스별로 존재해서 인스턴스와
스태틱 모두 다름, `synschronized` 스태틱 메서드같은경우 모든
인스턴스를 통틀어 특정 시점에 하나의 스레드만 실행 가능

`wait` 메서드는 다른 스레드가 이 모니터에 들어가 `notify` 를
호출할 때까지 모니터를 해제, 슬립 모드로 전환하도록 호출한 스레드에 명령


## 스레드 동기화

스레드 동기화 : 멀티 스레드 환경에서 공유된 자원에 같은 타이밍에
액세스할때 실행순서 제어하는것을 의미함. 일관성을 지키기위해 필요하다.

상태
- RUNNABLE : JVM에 실행중, OS 리소스할당 대기중
- BLOCKED : 모니터 락을 기다리면 차단됨
- WAITED : 그냥 무작정 기다리는 상태
- TIMED_WAITING : 특정시간만큼 대기
- TERMINATED : 비정상적 종료

notify
- 객체의 모니터에서 대기상태의 스레드 중하나를 깨워 활성화 상태되도록함
- 깨어난 스레드는 다른 스레드와 해당 객체에 대한 모니터 흭득을위해 경쟁함
, 스레드간의 우선순위는 따로 없음

### Thread Pool

Java 스레드는 시스템(OS) 스레드와 매핑된다.
따라서 제어없이 무분별하게 생성하면 리소스 낭비가 심하다.
멀티스레드의 작업을 관리하기 위해 스레드풀을 사용한다.

Task Submitters -> Task Queue -> Thread Pool

### ForkJoinPool

분할 정복 방식으로 병렬 처리 개선.
`fork` 로 작업을 분할하고 `join` 으로 분할된 작업을
재귀적으로 병합한다.

Parallel Stream : ForkJoin 프레임워크와
커먼스레드 풀을 사용한다.

### 스레드 구현 주의점

내꺼만 잘되는게 아니라 통합하고도 잘되는지 확인해야한다.
Common Thread Pool 은 JVM 레벨에서 모두가 같이 쓰는것이므로
총 100개인데 내가 50개 쓰고 다른사람이 70개쓰면 성능저하가
일어나니까 고려해야한다.

## 동기화 문제

- Race Condition : 경합상태, 이벤트 순서에 따라 시스템상태가바뀜
- DeadLock : 서로 흭득한 리소스 락걸고 무한히 대기
- LiveLock : 서로의 상태가 엇갈려 비활성상태(데드락은 상태변경이 업슨ㄴ데 라이브락은 리소스 상태계속 변경)
- Starvation : 필요한 공유리소스에 대해 액세스권한을 얻지못함
- Priority Inversion : 우선순위 높은작업이 낮은 작업으로 대체되어 공유리소스 기다림
- False Sharing : 분산시스템에 잘못된 캐싱메커니즘에 의해 발생하는 성능저하, 공유되는
데이터를 코어캐시에 의해 잘못 읽거나 필요없는 잘못된 참조로 인한 성능 저하

## Java 제공기능

### Synchronized 

멀티스레드에서 공유데이터에 대한 레이스컨디션 발생때 사용
, 인스턴스메소드, 스태틱메서드, 코드블록에 사용가능하다. 코드블록(락킹용 오브젝트)에 다는걸 추천한다.

주의사항
- 외부에서 락을 걸지 않을 객체에만 적용
- String 리터털은 풀링되기 때문에 가급적 사용하지말것, 사용하면 new 키워드와 함께 적용할것
- 박싱된 원시타입에 적용하지말것(클래스 생성해 적용할것)
- this 키워드로 Synchronized 를 적용하지 말것(락 객체 따로 구현해 사용)


### Volatile

캐싱과 재정렬같은 최적화로 인해 동시 컨텍스트에서 문제가 발생할 수 있는데
이런 문제를 메모리 순서제어로 해결하기 위한것.

실제로 동시성 문제를 해결하지 않는다.

### Atomic Class

공유데이터가 가변적인 경우 동시성 처리하지않으면(불변클래스 선언안할시) 동시성
오류 등이 쉽게 날 수 있다. 
- Synchronized 키워드 사용시
성능이슈가 있다(여러 스레드가 흭득 시도시 하나만 성공하고 나머지 스레드는 블락이 되기 때문)
- 원자적 연산 - 변경값을 업데이트하기전에 기존값이 그 전에 가져갔던 값과
동일한지를 확인 후 처리, 만약 다르면 아무것도 안한다.(스레드가 서스펜드
상태가 되지 않아 성능적으로 덜 영향 받음)

따라서 원자적 객체를 사용해 효과를 누릴 수 있다.

### Semaphore Class

카운팅 세마포어, 공유되는 리소스에 동시성 처리를 제한, 지원하기 위한 클래스
이며 스레드 수 제한 가능하다.
상황에 따라 바이너리 세마포어(뮤텍스)로도 사용가능하다.

### ReentrantLock Class

암묵적인 모니터락과 유사하지만 확장된 기능이 있는 재진입 뮤텍스 락
`fairness` 값이 true 면 가장 오래 기다린 스레드에 우선순위부여,
아니면 FIFO 로 등록

### ThreadLocal

스레드 별로 고유하게 보관되며 각 스레드는 복사본 변수를 갖게된다.
명시적으로 데이터를 삭제하지 않으면 남아있다. 그래서
스레드풀에서는 스레드가 사라지지 않으므로 이전에 사용하던
변수가 남아있게된다. 따라서 스레드풀과 사용하지않는다.

## 가상스레드

자바스레드는 OS 스레드에 매핑이 되므로 컨텍스트 스위칭이 발생한다.
Virtual Thread 를 사용하면 컨텍스트 스위칭을 줄일 수 있다.

## 벤치마킹

- currentTimeMills
- scouter
- 그라파나
- 프로메테우스
- 데이터독