# 커넥션 풀과 데이터소스

## 커넥션 풀

<img src="img/conn1.PNG">

데이터베이스 커넥션 흭득 과정

1. 애플리케이션 로직은 DB 드라이버를 통해 커넥션을 조회한다.
2. DB 드라이버는 DB와 TCP/IP 로 커넥션을 연결한다.
3. DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW 등 정보를 DB 에 전달한다
4. DB는 ID, PW 로 내부인증 완료하고, 내부에 DB 세션을 생성한다
5. DB는 커넥션생성이 완료되었다는 응답을 보낸다.
6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.

새로운 커넥션을 만드는 과정을 복잡하고 시간이 오래 걸린다. 이것을 해결하기위해 커넥션을 미리 생성하고 사용하는
커넥션 풀 방법이다.

<img src="img/conn2.PNG">

기본값으로 보통 커넥션 10개를 만들어 둔다. 해당 커넥션은 모두 DB에 TCP/IP 로 연결되어 있다. 애플리케이션은 DB 드라이버를 
이용해 커넥션을 얻는게 아닌 커넥션풀에게 커넥션을 요청한다. 애플리케이션은 커넥션을 다 사용하고나면 커넥션풀에 반환한다.

커넥션풀은 실무에 기본적으로 사용된다. 대표적인 오픈소스로 'HikariCP' 를 사용하고 스트링부트2.0 이후에는 'HikariCP' 를
기본으로 제공된다.

## DataSource

DB 드라이버와 커넥션 풀(HikariCP, DBCP2) 를 애플리케이션에 적용할려고 하면 DB 드라이버, 커넥션풀 종류마다 애플리케이션
코드가 다르게 적용된다. 이런 커넥션 흭득하는 방법을 추상화해서 통합해서 관리하기 위한것이 DataSource 이다.

<img src="img/conn3.PNG">

자바에서 `javax.sql.DataSource` 기본으로 제공한다. 

### 데이터소스와 드라이버

#### 드라이버 직접 사용
```java
@Test
void driverManager() throws SQLException {
    Connection con1 = DriverManager.getConnection(URL, USERNAME, PASSWORD);
    Connection con2 = DriverManager.getConnection(URL, USERNAME, PASSWORD);
    log.info("connection={}, class={}", con1, con1.getClass());
    log.info("connection={}, class={}", con2, con2.getClass());
}
```

#### 데이터소스 사용
```java
@Test
void dataSourceDriverManager() throws SQLException {
    //DriverManagerDataSource - 항상 새로운 커넥션 획득
    DriverManagerDataSource dataSource = new DriverManagerDataSource(URL,
    USERNAME, PASSWORD); useDataSource(dataSource);
}

private void useDataSource(DataSource dataSource) throws SQLException {
    Connection con1 = dataSource.getConnection();
    Connection con2 = dataSource.getConnection();
    log.info("connection={}, class={}", con1, con1.getClass());
    log.info("connection={}, class={}", con2, con2.getClass());
}
```

`DataSource` 를 사용하면 설정과 사용을 분리할 수 있다. 그냥 드라이버만 사용하면 DB 연결할때마다 설정정보를 넘겨 줘야하지만
`DataSource` 를 사용하면 설정 정보를 `DataSource` 가 만들어지는 시점에만 넘겨주면된다.

### 데이터소스와 커넥션 풀

#### 커넥션풀 히카리 사용
```java
@Test
void dataSourceConnectionPool() throws SQLException, InterruptedException {
    //커넥션 풀링: HikariProxyConnection(Proxy) -> JdbcConnection(Target)
    HikariDataSource dataSource = new HikariDataSource();
    dataSource.setJdbcUrl(URL);
    dataSource.setUsername(USERNAME);
    dataSource.setPassword(PASSWORD);
    dataSource.setMaximumPoolSize(10); // 커넥션 풀 최대 개수
    dataSource.setPoolName("MyPool"); // 커넥션 풀 이름 지정
        
    useDataSource(dataSource); // 실행
    Thread.sleep(1000); //커넥션 풀에서 커넥션 생성 시간 대기, 안정적인 로그찍기 위해 슬립걸음
}

private void useDataSource(DataSource dataSource) throws SQLException {
    Connection con1 = dataSource.getConnection();
    Connection con2 = dataSource.getConnection();
    log.info("connection={}, class={}", con1, con1.getClass());
    log.info("connection={}, class={}", con2, con2.getClass());
}
```
커넥션 풀에 커넥션을 별로의 쓰레드를 이용해서 채운다. 커넥션 풀 채우는 작업을 오래걸리기 때문이다.
커넥션풀이 커넥션을 흭득하기전에 커넥션 연결요청이 들어온경우 내부에서 사용할 수 있는 커넥션이 만들어질때까지 기다린뒤에 흭득한다.
만약 커넥션풀의 크기를 넘어가는 요청이 들어오면 사용중인 커넥션이 반환될 때까지 대기상태가된다. (몇초 넘어가면 연결을 끊는 등
설정을 해줘야 한다)

